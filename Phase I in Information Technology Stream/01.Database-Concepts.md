
---

# üìò **DATABASE CONCEPTS ‚Äî DETAILED NOTES**

# 1Ô∏è‚É£ **. DATABASE CONCEPTS**

A **database** is an organized collection of related data that can be accessed, managed, and updated easily.

### **1.1 Basic Terms**

| Term                                  | Meaning                                                                    |
| ------------------------------------- | -------------------------------------------------------------------------- |
| **Data**                              | Raw facts (e.g., 101, ‚ÄúJohn‚Äù, 60000)                                       |
| **Information**                       | Processed/meaningful data                                                  |
| **DBMS (Database Management System)** | Software used to create/manage databases (e.g., MySQL, Oracle, PostgreSQL) |
| **Schema**                            | Structure/blueprint of the database                                        |
| **Instance**                          | Snapshot of the database at a particular moment                            |
| **Metadata**                          | Data about data (table names, column types, etc.)                          |

### **1.2 Advantages of DBMS**

* Reduces data redundancy
* Ensures data integrity and consistency
* Supports security and authorization
* Allows concurrent access
* Backup and recovery
* Improved data sharing

---

#  2Ô∏è‚É£ **ER-MODEL (Entity‚ÄìRelationship Model)**


The **ER Model** is used for database design. It represents the real-world entities and the relationships among them.

## **1. Key Components**

### **a) Entity**

* Real-world object with independent existence.
* **Types**:

  * **Strong Entity** ‚Äì has its own primary key.
  * **Weak Entity** ‚Äì depends on a strong entity; identified via **partial key**.

### **b) Attributes**

* Properties of entity
* Example: Student ‚Üí RollNo, Name, Age

| Attribute Type | Example                           |
| -------------- | --------------------------------- |
| Simple         | Name                              |
| Composite      | Address = (Street, City, Pincode) |
| Single-valued  | RollNo                            |
| Multi-valued   | PhoneNumber                       |
| Derived        | Age (from DOB)                    |
| Key attribute  | RollNo                            |

---

### **c) Relationships**

* Associations between entities.
* Example:
**Student ‚Äî enrolls in ‚Äî Course**

####  **Degree of relationship**

* **Unary (1 entity)** ‚Äì e.g., Employee supervises Employee
* **Binary (2 entities)** ‚Äì most common
* **Ternary (3 entities)** ‚Äì e.g., Supplier‚ÄìPart‚ÄìWarehouse

| Degree  | Meaning              | Example                      |
| ------- | -------------------- | ---------------------------- |
| Unary   | Within same entity   | Employee supervises Employee |
| Binary  | Between two entities | Student‚ÄìCourse               |
| Ternary | Among three entities | Supplier‚ÄìPart‚ÄìWarehouse      |

---

### **e) Cardinality Ratios**

* Specifies number of entity occurrences in a relationship.

* **1:1**, **1:N**, **N:1**, **M:N**

| Type | Meaning      | Example         |
| ---- | ------------ | --------------- |
| 1:1  | One to One   | Person‚ÄìPassport |
| 1:N  | One to Many  | Dept‚ÄìEmployees  |
| M:N  | Many to Many | Student‚ÄìCourse  |

---

### **f) Participation Constraints**

* **Total Participation** ‚Äì every entity must participate
* **Partial Participation**

### **g) Weak Entity Representation**

* Double rectangle (entity), double diamond (relationship).

---

#  **RELATIONAL MODEL**

* The **relational model**, introduced by *E.F. Codd*, represents data in the form of **relations (tables)**.

---
## **1. Basic Terminology**

* **Relation** ‚Üí A table with rows and columns.
* **Tuple** ‚Üí Row [A row in table (record).]
* **Attribute** ‚Üí Column
* **Domain** ‚Üí Set of allowed attribute values [e.g Age domain = {0‚Äì120}]
* **Relation Schema** ‚Üí Structure [e.g., Student(Roll, Name, Age)]
* **Relation State** ‚Üí Actual table content at a point in time

## **2. Keys**


| Key Type          | Meaning                                      | Example                      |
| ----------------- | -------------------------------------------- | ---------------------------- |
| **Super key**     | Set of attributes uniquely identifying a row | {RollNo}, {RollNo, Name}     |
| **Candidate key** | Minimal super key                            | {RollNo}                     |
| **Primary key**   | Chosen candidate key                         | {RollNo}                         |
| **Alternate Key**   | remaining candidate keys      | {Name} |
| **Foreign key**   | References primary key of another table      | CourseID in Enrollment table |

---

# 3Ô∏è‚É£ **RELATIONAL ALGEBRA (Procedural Query Language)**

* Relational Algebra is a **theoretical query language** that uses **set-based operations** to manipulate relations.

## **Basic Operations**

### **1. Selection (œÉ)**

* Selects rows based on condition.
* Example:
**œÉ<sub>Age > 20</sub>(Student)**

### **2. Projection (œÄ)**

* Selects specific columns.
* Example:
**œÄ<sub>Name, Age</sub>(Student)**

### **3. Union ( ‚à™ )**

* Combines tuples of two relations.
* Both relations must be **union-compatible**.

* Example:
**`A ‚à™ B`**

### **4. Set Difference ( ‚àí )**

* Tuples in A but not in B.

* Example:
**`A ‚àí B`**

### **5. Cartesian Product (√ó)**

Pairs every tuple of A with every tuple of B.

### **6. Rename (œÅ)**

Renames relation or attributes.

œÅ<sub>NewName</sub>(Relation)

Example:
`œÅ R(A, B) (Relation)`

## **Advanced Operations**

### **7. Join (‚®ù)**

* **Natural Join**
  * `STUDENT ‚ãà ENROLLMENT`
* **Theta Join**
  * R ‚®ù<sub>condition</sub> S
* **Equi Join** 
  * Join using ‚Äú=‚Äù
* **Outer Joins (Left, Right, Full)**

### **8. Division (√∑)**

Used to answer queries like:
‚ÄúFind students who took all courses.‚Äù

---



# 4Ô∏è‚É£ **TUPLE CALCULUS (Non-procedural Query Language)**

## **Types**

1. **Tuple Relational Calculus (TRC)**
2. **Domain Relational Calculus (DRC)**

## **TRC Syntax**

{ t | P(t) }
t ‚Üí tuple variable
P(t) ‚Üí predicate (condition)

Example:
{ t | t ‚àà Student ‚àß t.Age > 20 }

## **DRC Syntax**

{ <a‚ÇÅ, a‚ÇÇ ‚Ä¶> | P(a‚ÇÅ, a‚ÇÇ ‚Ä¶) }

Example:
{ <n> | ‚àÉr ‚àà Student (r.Name = n ‚àß r.Age > 20) }

---

# 5Ô∏è‚É£ **INTEGRITY CONSTRAINTS**

## **1. Domain Constraints**

Attribute values must belong to a valid domain.

## **2. Entity Integrity**

Primary key cannot be NULL.

## **3. Referential Integrity**

Foreign key must refer to an existing primary key (or be NULL).

## **4. Key Constraints**

No two tuples can have same primary key.

## **5. Business / Semantic Constraints**

Application-specific rules (e.g., Salary > 0).

---

# 6Ô∏è‚É£ **NORMAL FORMS**

## **1. Functional Dependency (FD)**

X ‚Üí Y means: Attribute set X uniquely determines Y.

---

## **2. 1NF: First Normal Form**

* No multi-valued or composite attributes.
* All attributes atomic.

---

## **3. 2NF: Second Normal Form**

* Must be in **1NF**
* No **partial dependency** (i.e., non-key attributes must depend on entire primary key)

Applicable only when PK is composite.

---

## **4. 3NF: Third Normal Form**

* Must be in **2NF**
* No **transitive dependency**
  (A ‚Üí B ‚Üí C where A is primary key)

---

## **5. BCNF (Boyce‚ÄìCodd Normal Form)**

* For every FD: **X ‚Üí Y**

  * X must be a **super key**

BCNF is stricter than 3NF.

---

## **6. 4NF**

* No multi-valued dependencies.

---

## **7. 5NF**

* No join dependency anomalies.

---

# 7Ô∏è‚É£ **FILE ORGANIZATION**

## **1. Heap (Unordered) File**

* Records stored randomly.
* Pros: Insertions fast
* Cons: Searches slow

## **2. Sequential File**

* Records stored in sorted order.
* Pros: Fast range queries
* Cons: Insert slow (need reordering)

## **3. Hashing**

* Hash function computes block address.
* Pros: O(1) lookup
* Cons: Poor for range queries

### Types:

* **Static Hashing**
* **Dynamic Hashing** (Extendible, Linear Hashing)

---

# 8Ô∏è‚É£ **INDEXING**

Indexes improve search performance.

## **1. Primary Index**

* Built on primary key
* Sparse index

## **2. Secondary Index**

* Built on non-key attribute
* Dense index

## **3. Clustering Index**

* Index on non-primary key that orders data blocks.

---

## **4. B-Tree Index**

### Characteristics:

* Self-balancing search tree
* Node contains **keys + pointers**
* All leaf nodes at the same level
* Good for random and range queries

### Operations

* Search: O(log n)
* Insert / Delete maintain balance

---

## **5. B+-Tree Index**

Most widely used in databases.

### Key Features:

* All keys stored only in **leaf nodes**
* Internal nodes store only routing keys
* Leaf nodes linked as a linked list (good for range queries)
* Better space utilization and read efficiency

### Advantages:

* Faster range search
* Balanced at all times
* Supports disk-based indexing efficiently

---

# 9Ô∏è‚É£ **TRANSACTIONS AND CONCURRENCY CONTROL**

## **1. Transaction**

Sequence of operations that form a single logical unit of work.

### **ACID Properties**

* **Atomicity** ‚Äì all or nothing
* **Consistency** ‚Äì DB moves from one valid state to another
* **Isolation** ‚Äì intermediate states invisible to others
* **Durability** ‚Äì changes persist even after crash

---

## **2. Concurrency Problems**

Occurs when multiple transactions execute simultaneously.

### **Anomalies:**

1. **Dirty Read** ‚Äì reading uncommitted data
2. **Unrepeatable Read** ‚Äì same query returns different results
3. **Phantom Read** ‚Äì new rows appear when re-reading
4. **Lost Update** ‚Äì two updates overwrite each other

---

## **3. Concurrency Control Techniques**

### **a) Locking**

* **Shared Lock (S)** ‚Äì read
* **Exclusive Lock (X)** ‚Äì write

### **Two-Phase Locking (2PL)**

* Growing phase ‚Üí acquire locks
* Shrinking phase ‚Üí release locks
  Guarantees **serializability**.

### **Types of 2PL**

* **Strict 2PL** ‚Äì release locks at transaction end
* **Rigorous 2PL** ‚Äì stronger, all locks held till commit

---

### **b) Timestamp Ordering**

* Each transaction assigned timestamp
* Conflicts resolved based on timestamps

---

### **c) Optimistic Concurrency Control**

* Assumes conflicts are rare
* Validation before commit

---

## **4. Deadlock**

Two transactions wait for each other.

### **Deadlock Handling**

* **Prevention** (ordering of locks)
* **Detection and Recovery** (wait-for graph)
* **Timeout**

---

## **5. Recovery Techniques**

### **a) Log-based Recovery**

* Undo/redo using log
* Write-Ahead Logging (WAL)

### **b) Checkpointing**

* Reduces recovery time

---

