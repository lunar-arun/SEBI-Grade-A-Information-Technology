
---

# 1️⃣ **STRING BASICS**

A **string** is a sequence of characters.
Stored as:

* **Character array** (C, C++)
* **Immutable object** (Java, Python)
* **Mutable object** in some languages (StringBuilder in Java)

Key characteristics:

* Zero-indexed
* May be mutable or immutable
* Stored as contiguous memory (in most languages)

---

# 2️⃣ **STRING LENGTH**

## **Definition**

Length of a string = **number of characters** present in it.

Examples:

* `"SEBI"` → length = 4
* `"Grade A"` → length = 7 (includes space)

## **How length is determined**

* C: Loop until `'\0'` terminator is found
* Java: `str.length()`
* Python: `len(str)`

## **Time Complexity**

* Usually **O(1)** in modern languages (length stored internally)
* In C (null-terminated), **O(n)**

---

# 3️⃣ **SUBSTRING**

## **Definition**

A **substring** is a continuous portion of a string.

Example:

* From `"information"` → `"inform"`, `"nation"`, `"form"`

## **Operations**

Common methods:

* Python: `s[2:6]`
* Java: `s.substring(start, end)`
* C/C++: manual extraction using indices

## **Properties**

* Substring length = `end_index - start_index`
* Copying a substring typically costs **O(k)** where *k* = substring length

## **Use Cases**

* Parsing text
* Extracting tokens from financial logs
* Data cleaning
* Input validation

---

# 4️⃣ **REGEX (Regular Expressions)**

## **Definition**

A **regex** is a pattern used to match, search, or manipulate strings.

Regex engines are used for:

* Validation
* Searching
* Tokenizing
* Replacing strings
* Pattern extraction

## **Common Regex Symbols**

### **Character Classes**

* `[a-z]` → lowercase letters
* `[A-Z]` → uppercase
* `[0-9]` → digits
* `\w` → word characters
* `\d` → any digit
* `\s` → whitespace

### **Quantifiers**

* `*` → 0 or more
* `+` → 1 or more
* `?` → 0 or 1
* `{m,n}` → between m and n times

### **Anchors**

* `^` → start of string
* `$` → end of string
* `\b` → word boundary

### **Examples**

* Email: `^[\w\.-]+@[\w\.-]+\.\w{2,3}$`
* PAN format (India): `^[A-Z]{5}[0-9]{4}[A-Z]$`
* Date (YYYY-MM-DD): `^\d{4}-\d{2}-\d{2}$`

## **Time Complexity**

* Simple regex: **O(n)**
* Backtracking-based regex (e.g., `(.+)+`) can be **exponential**
* Modern engines optimize common patterns

## **Applications**

* Market data validation
* Log file analysis
* Input sanitization
* Web form authentication
* NLP pre-processing

---

# 5️⃣ **STRING SEARCH**

Searching means finding a **pattern** inside a larger **text string**.

---

## ⭐ 1. **Naïve Search**

### Idea:

Compare the pattern at every possible position in the text.

### Complexity:

* Worst: **O(n × m)**
  (n = text length, m = pattern length)

### Example:

Searching `"man"` inside `"information"`

---

## ⭐ 2. **KMP (Knuth–Morris–Pratt)**

### Idea:

Preprocess pattern using **LPS (Longest Prefix Suffix)** array to skip unnecessary comparisons.

### Complexity:

* **O(n + m)**

### Best use:

Repeated pattern matching in long texts.

---

## ⭐ 3. **Rabin–Karp**

### Idea:

Use **hashing** for faster comparison.
If hash matches, verify exact match.

### Complexity:

* Average: **O(n + m)**
* Worst: **O(n × m)** (hash collisions)

### Best use:

Searching **multiple patterns** simultaneously.

---

## ⭐ 4. **Boyer–Moore Search**

### Idea:

Match pattern from **right to left**, skip multiple characters using:

* Bad Character Rule
* Good Suffix Rule

### Complexity:

* Best: **O(n / m)** (very fast in practice)
* Worst: **O(n × m)**

### Best use:

* Large text bodies
* Searching in documents/editors

---

# 6️⃣ **STRING MANIPULATION OPERATIONS**

## **Common operations**

| Operation | Description                    | Average Time |
| --------- | ------------------------------ | ------------ |
| `concat`  | Combine two strings            | O(n)         |
| `replace` | Replace substring/char         | O(n)         |
| `split`   | Split on delimiter             | O(n)         |
| `trim`    | Remove leading/trailing spaces | O(n)         |
| `compare` | Lexicographical comparison     | O(n)         |
| `reverse` | Reverse the string             | O(n)         |

**n = length of string**

## **Immutable vs Mutable**

* Java `String` = **immutable** → costly concatenations
* Java `StringBuilder` = **mutable** → efficient
* Python strings = immutable
* Python `list()` can be used for efficient modifications

---

# 7️⃣ **STRING STORAGE & MEMORY**

### **ASCII String**

* 1 byte per character

### **Unicode String**

* UTF-8 (1–4 bytes)
* UTF-16 (2 bytes)
* UTF-32 (4 bytes)

Languages store strings internally using different encodings.

---

# 8️⃣ **PRACTICAL USE CASES IN FINANCE / SEBI CONTEXT**

* Parsing **stock tickers**: extracting symbols
* Processing **trading logs**
* Detecting fraud patterns using regex
* Extracting numbers/dates from filings
* Validating PAN, Aadhaar, ISIN using regex
* Cleaning textual data for NLP-based sentiment analysis

---


