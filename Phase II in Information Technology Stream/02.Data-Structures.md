
---

# üìò **DATA STRUCTURES ‚Äî Detailed Notes for SEBI Grade A IT (Phase II)**

A **Data Structure** is a way of organizing, storing, and managing data so that it can be used efficiently.

Common examples: **Array, Linked List, Stack, Queue, Tree, Graph, Hash Table**, etc.

---

# 1Ô∏è‚É£ **ARRAY**

## **Definition**

An **Array** is a collection of elements stored in **contiguous (continuous) memory locations**, all having the **same data type**.
Each element is accessed using its **index**.

Example:
`int A[5] = {10, 20, 30, 40, 50};`

Memory representation:

| Index | 0  | 1  | 2  | 3  | 4  |
| ----- | -- | -- | -- | -- | -- |
| Value | 10 | 20 | 30 | 40 | 50 |

---

## **Key Features**

* Fixed size (cannot grow or shrink).
* Fast access using index (O(1) time).
* Stores homogeneous data (same type).

---

## **Types of Arrays**

1. **One-Dimensional Array**
2. **Two-Dimensional Array** (Matrix)
3. **Multi-Dimensional Array**

---

## **Operations & Complexity**

| Operation            | Average Case |
| -------------------- | ------------ |
| Access               | **O(1)**     |
| Search               | **O(n)**     |
| Insert (at position) | **O(n)**     |
| Delete               | **O(n)**     |

## **Advantages**

* Simple and easy to use.
* Fast access through index.
* Continuous memory usage makes operations like sorting easier.

## **Disadvantages**

* Fixed size (cannot increase at runtime).
* Insertion/deletion in the middle is slow.
* Wastes memory if array size is too large.

## **Applications**

* Matrices
* Lookup tables
* Implementing heaps, hash tables, etc.

---

# 2Ô∏è‚É£ **LINKED LIST**

## **Definition**

A **linked list** is a linear data structure where elements (nodes) are stored at non-contiguous memory locations and connected using pointers.

A **Linked List** is a dynamic data structure consisting of **nodes**.
Each *node* contains two parts:

1. **Data**
2. **Pointer** (address of the next node)

A linked list uses **non-contiguous memory locations**.

Diagram:

```
[Data|Next] ‚Üí [Data|Next] ‚Üí [Data|Next] ‚Üí NULL
```

## **Types of Linked Lists**

1. **Singly Linked List** (each node points to next)
2. **Doubly Linked List** (points to next and previous)
3. **Circular Linked List** (last node points to first)
4. **Circular Doubly Linked List**


## **Complexity**

| Operation                | Time Complexity |
| ------------------------ | --------------- |
| Access element           | O(n)            |
| Search element           | O(n)            |
| Insert node (head)       | O(1)            |
| Insert node (middle/end) | O(n)            |
| Delete node (head)       | O(1)            |
| Delete node (middle/end) | O(n)            |

---

## **Advantages**

* Dynamic size (can grow or shrink at runtime)
* Easy insertion and deletion
* Better memory utilization (no unused spaces)

---

## **Disadvantages**

* Slow traversal (must traverse from head)
* Extra memory required for storing pointers
* Not cache-friendly (not stored continuously)

---
## **Uses**

* Queues, stacks
* Graph adjacency lists
* Memory management

---
---

# 3Ô∏è‚É£ **STACK**

## **Definition**

A **Stack** is a linear data structure that follows the **LIFO** principle:

### **LIFO ‚Üí Last In, First Out**

This means:

* The last element inserted is the first one removed.

## **Diagram**

```
   TOP ‚Üí [ 30 ]
          [ 20 ]
          [ 10 ]
 Bottom ‚Üí [ 5  ]
```


## **Basic Operations**

| Operation          | Meaning                                       |
| ------------------ | --------------------------------------------- |
| **push(x)**        | Insert element x onto stack                   |
| **pop()**          | Remove top element                            |
| **peek() / top()** | View top element                              |
| **isEmpty()**      | Check if stack is empty                       |
| **isFull()**       | Check if stack is full (array implementation) |


## **Complexity**

| Operation | Time     |
| --------- | -------- |
| Push/Pop  | **O(1)** |
| Search    | **O(n)** |

---

## **Advantages**

* Easy to implement
* Fast operations (push/pop)
* Memory efficient (linked list implementation grows dynamically)

---

## **Disadvantages**

* Limited size in array-based stack
* Only top accessible (no random access)

---

## **Applications**

* Function calls (call stack)
* Undo/Redo operations
* Balanced parentheses
* Expression evaluation (postfix/prefix)

---
=--

# 4Ô∏è‚É£ **QUEUE**

## **Definition**

A **Queue** is a linear data structure that follows the **FIFO** principle:

### **FIFO ‚Üí First In, First Out**

This means:

* The first element inserted is the first one removed.

---

## **Diagram**

```
Front ‚Üí [10] [20] [30] [40] ‚Üê Rear
```

---

## **Basic Operations**

| Operation      | Meaning                                       |
| -------------- | --------------------------------------------- |
| **enqueue(x)** | Insert element x at rear                      |
| **dequeue()**  | Remove element from front                     |
| **peek()**     | View front element                            |
| **isEmpty()**  | Check if queue is empty                       |
| **isFull()**   | Check if queue is full (array implementation) |

---

## **Time Complexity**

| Operation | Time |
| --------- | ---- |
| Enqueue   | O(1) |
| Dequeue   | O(1) |
| Peek      | O(1) |

## **Types of Queues**

1. **Simple Queue**
2. **Circular Queue**
3. **Priority Queue**
4. **Double-Ended Queue (Deque)**

---

## **1. Simple Queue**

Elements are added at the **rear** and removed from the **front**.

Problem: After many enqueues and dequeues, space may get wasted.

---

## **2. Circular Queue**

Solves wasted space problem by treating queue as circular.

Diagram:

```
   front ‚Üì         rear ‚Üì
[ 40 ] [ 50 ] [ 10 ] [ 20 ] [ 30 ]
```

---

## **3. Priority Queue**

Highest priority element is removed first (not FIFO).

Example:
Hospital emergency room.

---

## **4. Deque (Double Ended Queue)**

Insertion and deletion allowed from **both ends**.

---

## **Advantages**

* Efficient for managing order of tasks
* Supports constant time insertion/deletion
* Circular queue avoids memory wastage

---

## **Disadvantages**

* Fixed size in static array implementation
* Dequeue in simple queue wastes memory
* No random access (must go through front)

---

## **Applications**

* CPU scheduling
* Buffer management (IO)
* BFS traversal in graphs

---
---

# 5Ô∏è‚É£ **BINARY TREE**

## **Definition**

A hierarchical data structure where each node has at most **two children**: left and right.

## **Terminology**

* Root, Parent, Child
* Level, Height
* Leaf node
* Full/Complete/Perfect Binary Trees

## **Traversals**

### 1. **DFS Traversals**

* **Preorder:** Root ‚Üí Left ‚Üí Right
* **Inorder:** Left ‚Üí Root ‚Üí Right
* **Postorder:** Left ‚Üí Right ‚Üí Root

### 2. **BFS Traversal**

* Level Order Traversal (using queue)

## **Complexity**

| Operation              | Time                    |
| ---------------------- | ----------------------- |
| Insert, Delete, Search | **O(n)** (not balanced) |

## **Applications**

* Expression trees
* Compression (Huffman)
* Routing tables

---

# 6Ô∏è‚É£ **INDEXING**

## **Definition**

Indexing is a data structure technique to access records in **reduced time** without scanning the entire dataset.

## **Types**

1. **Primary Index** ‚Äì on primary key
2. **Secondary Index** ‚Äì on non-key attribute
3. **Dense Index** ‚Äì index entry for *every* record
4. **Sparse Index** ‚Äì entry for *some* records
5. **B-Tree / B+ Tree Indexes** (Databases)

## **Importance in SEBI/Finance**

Efficient indexing is crucial in:

* High-volume trading systems
* Database query optimization
* Real-time analytics

---

# 7Ô∏è‚É£ **BINARY SEARCH TREE (BST)**

## **Definition**

A binary tree with properties:

* Left subtree contains nodes with keys **less** than root
* Right subtree contains nodes **greater**
* No duplicates (usually)

## **Operations Complexity**

| Operation | Average      | Worst    |
| --------- | ------------ | -------- |
| Search    | **O(log n)** | **O(n)** |
| Insert    | O(log n)     | O(n)     |
| Delete    | O(log n)     | O(n)     |

Worst case happens when tree becomes **skewed**.

## **Balanced BSTs**

* AVL Tree
* Red-Black Tree
* Splay Tree

These guarantee **O(log n)** operations.

---

# 8Ô∏è‚É£ **HEAP**

## **Definition**

A **complete binary tree** that satisfies the **heap property**:

* **Min-Heap:** Parent ‚â§ children
* **Max-Heap:** Parent ‚â• children

Stored as arrays using index-based calculations.

## **Operations**

| Operation      | Time     |
| -------------- | -------- |
| Insert         | O(log n) |
| Delete/Extract | O(log n) |
| Get min/max    | O(1)     |

## **Applications**

* **Heap Sort**
* Priority Queues
* Dijkstra‚Äôs Algorithm
* Scheduling processes

---

# 9Ô∏è‚É£ **HASHING**

## **Definition**

A technique of mapping keys to buckets using a **hash function**.

## **Hash Function**

`index = h(key)`

## **Collision Resolution Techniques**

1. **Open Addressing**

   * Linear Probing
   * Quadratic Probing
   * Double Hashing
2. **Separate Chaining**

   * Linked lists at each index

## **Complexity**

| Operation | Average  | Worst    |
| --------- | -------- | -------- |
| Search    | **O(1)** | **O(n)** |
| Insert    | O(1)     | O(n)     |
| Delete    | O(1)     | O(n)     |

## **Applications**

* Database indexing
* Caches
* Symbol tables
* Blockchain (hash functions)

---

# üîü **MATRIX**

A matrix is a 2D array structure.

## **Representation**

```
matrix[i][j]
```

## **Types**

* Sparse matrix
* Dense matrix
* Identity matrix
* Upper/Lower triangular matrix

## **Matrix Storage for Efficiency**

* **CSR (Compressed Sparse Row)**
* **CSC (Column Sparse Column)**

## **Applications**

* Graph adjacency matrix
* Machine learning computations
* Scientific computing

---

# 1Ô∏è‚É£1Ô∏è‚É£ **JSON OBJECTS**

## **Definition**

**JSON (JavaScript Object Notation)** is a lightweight, text-based data structure used for representing structured data.

## **Structure**

```
{
  "key": "value",
  "array": [1,2,3],
  "object": {"a": 1}
}
```

## **Characteristics**

* Human-readable
* Supports primitive + structured types
* Common format for APIs, configuration files

## **Data Types**

* String
* Number
* Boolean
* Null
* Array
* Object

## **Use Cases in IT/Finance**

* REST APIs (market data, trading systems)
* Web services
* NoSQL databases (MongoDB)

---
