
---

# **ðŸ“˜ BASIC LEVEL â€“ 15 MCQs (Code-Based)**

---

### **1. What is the time complexity of the following code?**

```cpp
for(int i = 0; i < n; i++) {
    // constant work
}
```

A. O(log n)
B. O(n)
C. O(n log n)
D. O(nÂ²)

---

### **2. Output of the following Bubble Sort pass (first pass only):**

```python
arr = [5, 1, 4, 2]
# First pass
for i in range(len(arr)-1):
    if arr[i] > arr[i+1]:
        arr[i], arr[i+1] = arr[i+1], arr[i]
print(arr)
```

A. [1, 5, 2, 4]
B. [1, 4, 2, 5]
C. [1, 5, 4, 2]
D. [1, 2, 4, 5]

---

### **3. What will Binary Search return for target=7?**

```java
int[] arr = {2, 4, 7, 9, 12};
int low = 0, high = arr.length - 1;
while(low <= high){
    int mid = (low + high)/2;
    if(arr[mid] == 7) return mid;
    else if(arr[mid] < 7) low = mid + 1;
    else high = mid - 1;
}
```

A. 0
B. 2
C. 3
D. -1

---

### **4. What is the pivot chosen in this QuickSort snippet?**

```cpp
int pivot = arr[high];
```

A. First element
B. Last element
C. Middle element
D. Random element

---

### **5. What does this greedy algorithm compute?**

```python
coins = [10, 5, 1]
amount = 17
count = 0
for c in coins:
    count += amount // c
    amount = amount % c
print(count)
```

A. Minimum number of coins
B. Sum of coins
C. Maximum coin value
D. Invalid output

---

### **6. What is the time complexity of Linear Search?**

A. O(1)
B. O(log n)
C. O(n)
D. O(nÂ²)

---

### **7. What is printed by this code?**

```python
def fun(n):
    if n == 0:
        return 1
    return n * fun(n-1)

print(fun(3))
```

A. 3
B. 6
C. 9
D. 1

---

### **8. Identify the algorithm used:**

```cpp
for(int gap = n/2; gap > 0; gap /= 2){
    for(int i = gap; i < n; i++){
        int temp = arr[i];
        int j;
        for(j = i; j >= gap && arr[j-gap] > temp; j -= gap){
            arr[j] = arr[j-gap];
        }
        arr[j] = temp;
    }
}
```

A. Merge Sort
B. Quick Sort
C. Shell Sort
D. Selection Sort

---

### **9. Output of this pattern searching snippet (naive)?**

```python
text = "abcxabcdabcd"
pat = "abcd"
print(text.find(pat))
```

A. 3
B. 4
C. 5
D. 6

---

### **10. What is the recurrence for Merge Sort?**

A. T(n)=T(nâˆ’1)+1
B. T(n)=2T(n/2)+O(n)
C. T(n)=T(n/2)+O(1)
D. T(n)=nT(nâˆ’1)

---

### **11. What will this backtracking code print?**

```python
def solve(arr, idx):
    if idx == len(arr):
        print(arr)
        return
    for i in range(idx, len(arr)):
        arr[idx], arr[i] = arr[i], arr[idx]
        solve(arr, idx+1)
        arr[idx], arr[i] = arr[i], arr[idx]

solve([1,2], 0)
```

A. Only [1,2]
B. Only [2,1]
C. [1,2] and [2,1]
D. Error

---

### **12. What is the time complexity of pattern search using `str.find()` in Python?**

A. O(n) average
B. O(log n)
C. O(nÂ²)
D. Constant time

---

### **13. What does this greedy code do?**

```cpp
int sum = 0;
sort(arr, arr+n); // ascending
for(int i=0; i<n; i++){
    sum += arr[i];
}
```

A. Computes prefix sums
B. Minimizes sum
C. Sorts and returns total sum
D. Maximum subarray sum

---

### **14. What is the output?**

```python
arr = [2, 3, 1]
for i in range(len(arr)):
    min_i = i
    for j in range(i+1, len(arr)):
        if arr[j] < arr[min_i]:
            min_i = j
    arr[i], arr[min_i] = arr[min_i], arr[i]

print(arr)
```

A. [2, 3, 1]
B. [1, 2, 3]
C. [3, 2, 1]
D. [1, 3, 2]

---

### **15. Identify algorithm type:**

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)
```

A. Dynamic programming (top-down with memo)
B. Greedy
C. Simple recursion
D. Backtracking

---
---

| **Q.No** | **Answer** |
| -------- | ---------- |
| 1        | B          |
| 2        | A          |
| 3        | B          |
| 4        | B          |
| 5        | A          |
| 6        | C          |
| 7        | B          |
| 8        | C          |
| 9        | D          |
| 10       | B          |
| 11       | C          |
| 12       | A          |
| 13       | C          |
| 14       | B          |
| 15       | C          |

---
---

# **ðŸ“˜ MEDIUM LEVEL â€“ 15 MCQs**

---

### **1. What is the time complexity of the following merge function?**

```cpp
void merge(int arr[], int l, int m, int r){
    int n1 = m - l + 1;
    int n2 = r - m;
    int i=0, j=0, k=l;
    while(i<n1 && j<n2){
        if(L[i] <= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }
}
```

A. O(1)
B. O(log n)
C. O(n)
D. O(n log n)

---

### **2. What is printed by the QuickSort partition function?**

```python
arr = [9, 3, 7, 5, 6]
pivot = arr[-1]
i = -1
for j in range(len(arr)-1):
    if arr[j] < pivot:
        i += 1
        arr[i], arr[j] = arr[j], arr[i]
print(i)
```

A. 1
B. 2
C. 3
D. 0

---

### **3. What does this greedy algorithm compute?**

```python
activities = [(1,3), (2,4), (3,5), (0,6)]
activities.sort(key=lambda x: x[1])
count = 1
end = activities[0][1]
for act in activities[1:]:
    if act[0] >= end:
        count += 1
        end = act[1]
print(count)
```

A. Number of maximum overlapping activities
B. Maximum number of non-overlapping activities
C. Minimum activities
D. Number of invalid intervals

---

### **4. Output of this Binary Search variant?**

```cpp
int arr[] = {1, 2, 4, 4, 4, 6};
int target = 4;
int low=0, high=5, ans=-1;
while(low <= high){
    int mid = (low+high)/2;
    if(arr[mid] == target){
        ans = mid;
        high = mid - 1;
    } else if(arr[mid] > target){
        high = mid - 1;
    } else low = mid + 1;
}
cout << ans;
```

A. 2
B. 3
C. 4
D. 1

---

### **5. What is printed? (Knapsack DP)**

```python
dp = [[0]*4 for _ in range(3)]
wt = [1,2,3]
val = [6,10,12]
W = 3
for i in range(1,3):
    for w in range(1,4):
        if wt[i-1] <= w:
            dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w])
        else:
            dp[i][w] = dp[i-1][w]
print(dp[2][3])
```

A. 12
B. 16
C. 22
D. 10

---

### **6. Which sorting algorithm does this code represent?**

```python
for i in range(n):
    min_index = i
    for j in range(i+1, n):
        if arr[j] < arr[min_index]:
            min_index = j
    arr[i], arr[min_index] = arr[min_index], arr[i]
```

A. Insertion Sort
B. Selection Sort
C. Merge Sort
D. Heap Sort

---

### **7. What is the worst-case time complexity of the following backtracking solution?**

```python
def permute(arr, l):
    if l == len(arr):
        return
    for i in range(l, len(arr)):
        arr[l], arr[i] = arr[i], arr[l]
        permute(arr, l+1)
        arr[l], arr[i] = arr[i], arr[l]
```

A. O(n)
B. O(n log n)
C. O(nÂ²)
D. O(n!)

---

### **8. What is the space complexity of Merge Sort?**

A. O(1)
B. O(log n)
C. O(n)
D. O(nÂ²)

---

### **9. What is printed by this binary search (upper bound)?**

```python
arr = [2, 3, 5, 7, 7, 8]
target = 7
low, high = 0, len(arr)-1
ans = -1
while low <= high:
    mid = (low+high)//2
    if arr[mid] > target:
        ans = mid
        high = mid - 1
    else:
        low = mid + 1
print(ans)
```

A. 3
B. 4
C. 5
D. -1

---

### **10. What is the output? (Kadane's Algorithm)**

```python
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
max_ending = max_so_far = arr[0]
for i in arr[1:]:
    max_ending = max(i, max_ending + i)
    max_so_far = max(max_so_far, max_ending)
print(max_so_far)
```

A. 4
B. 5
C. 6
D. 7

---

### **11. Time complexity of KMP prefix-function computation?**

A. O(nÂ²)
B. O(n)
C. O(log n)
D. O(n log n)

---

### **12. Output of this divide & conquer function?**

```python
def fun(n):
    if n <= 1:
        return 1
    return fun(n//2) + fun(n//2)
print(fun(8))
```

A. 1
B. 2
C. 4
D. 8

---

### **13. What is the recurrence solved by the Master Theorem?**

```text
T(n) = 9T(n/3) + n
```

A. Î¸(n)
B. Î¸(n log n)
C. Î¸(nÂ²)
D. Î¸(nÂ³)

---

### **14. Which algorithm does this represent?**

```python
i = 1
while i < n:
    i = i * 2
```

A. O(nÂ²) algorithm
B. Logarithmic algorithm
C. Backtracking
D. DP

---

### **15. What is the output? (Insertion Sort â€“ Partial)**

```python
arr = [4, 3, 5, 1]
for i in range(1, 3):
    key = arr[i]
    j = i - 1
    while j >= 0 and arr[j] > key:
        arr[j+1] = arr[j]
        j -= 1
    arr[j+1] = key
print(arr)
```

A. [3, 4, 5, 1]
B. [3, 4, 1, 5]
C. [4, 3, 1, 5]
D. [1, 3, 4, 5]

---

| **Q.No** | **Answer** |
| -------- | ---------- |
| 1        | C          |
| 2        | A          |
| 3        | B          |
| 4        | A          |
| 5        | B          |
| 6        | B          |
| 7        | D          |
| 8        | C          |
| 9        | C          |
| 10       | C          |
| 11       | B          |
| 12       | D          |
| 13       | C          |
| 14       | B          |
| 15       | A          |

---
---

# **ðŸ“˜ ADVANCED LEVEL â€“ 15 MCQs**

---

### **1. What is the time complexity of this modified binary search?**

```python
while low <= high:
    mid = (low + high)//2
    if arr[mid] == target:
        high = mid - 1
    elif arr[mid] > target:
        high = mid - 1
    else:
        low = mid + 1
```

A. O(log n)
B. O(n)
C. O(n log n)
D. O(nÂ²)

---

### **2. What is printed by this QuickSort partition?**

```python
arr = [8, 4, 7, 3, 10, 2]
pivot = arr[2]    # pivot = 7
i = 0
for j in range(0, len(arr)):
    if arr[j] < pivot:
        arr[i], arr[j] = arr[j], arr[i]
        i += 1
print(i)
```

A. 1
B. 3
C. 4
D. 5

---

### **3. What does this DP compute?**

```python
dp = [0]* (n+1)
for i in range(1, n+1):
    dp[i] = dp[i-1] + dp[i-2] + 1
```

A. Fibonacci numbers
B. Tribonacci numbers
C. Counting number of binary strings
D. Custom recurrence (linear DP)

---

### **4. Output of this KMP prefix function?**

```python
s = "ababcabab"
pi = [0]*len(s)
for i in range(1, len(s)):
    j = pi[i-1]
    while j > 0 and s[i] != s[j]:
        j = pi[j-1]
    if s[i] == s[j]:
        j += 1
    pi[i] = j
print(pi[-1])
```

A. 2
B. 3
C. 4
D. 5

---

### **5. Time complexity of this divide & conquer recurrence?**

```text
T(n) = 3T(n/2) + n log n
```

A. Î¸(n log n)
B. Î¸(n^logâ‚‚3)
C. Î¸(nÂ²)
D. Î¸(n logÂ² n)

---

### **6. Output of this bitonic search?**

```python
arr = [1, 4, 8, 12, 9, 6, 3]
# find peak
low, high = 0, len(arr)-1
while low < high:
    mid = (low + high)//2
    if arr[mid] < arr[mid+1]:
        low = mid + 1
    else:
        high = mid
print(low)
```

A. 2
B. 3
C. 4
D. 1

---

### **7. Complexity of this backtracking Sudoku snippet?**

```python
def solve(grid):
    find = empty_cell(grid)
    if not find:
        return True
    r, c = find
    for num in range(1,10):
        if safe(grid, r, c, num):
            grid[r][c] = num
            if solve(grid):
                return True
            grid[r][c] = 0
    return False
```

A. O(9n)
B. O(nÂ²)
C. O(9^(n))
D. Exponential

---

### **8. What does this greedy code compute?**

```python
arr = [3, 1, 2, 1, 4]
arr.sort()
wait = 0
total = 0
for i in arr:
    total += wait
    wait += i
print(total)
```

A. Minimized maximum waiting time
B. Minimized total waiting time
C. Sum of all elements
D. Maximum subarray sum

---

### **9. What is the time complexity?**

```cpp
for(int i=1; i<n; i*=2){
    for(int j=0; j<i; j++){
        // work
    }
}
```

A. O(n)
B. O(n log n)
C. O(nÂ²)
D. O(n logÂ² n)

---

### **10. Output of Rabin-Karp hash window movement?**

```python
text = "aaaa"
pat = "aa"
base = 26
h = 0
for ch in pat:
    h = h*base + (ord(ch)-97)
print(h)
```

A. 26
B. 27
C. 52
D. 28

---

### **11. DP recurrence meaning?**

```python
dp[i][j] = min(
    dp[i-1][j] + 1,
    dp[i][j-1] + 1,
    dp[i-1][j-1] + (s1[i]!=s2[j])
)
```

A. Longest common subsequence
B. Edit distance
C. Matrix chain multiplication
D. LIS

---

### **12. Output of this divide & conquer sum?**

```python
def sumArr(arr, l, r):
    if l == r:
        return arr[l]
    mid = (l+r)//2
    return sumArr(arr, l, mid) + sumArr(arr, mid+1, r)

print(sumArr([3,2,1,4],0,3))
```

A. 10
B. 9
C. 11
D. 8

---

### **13. What is the worst-case complexity of QuickSort (last-element pivot)?**

A. O(n log n)
B. O(n)
C. O(nÂ²)
D. O(1)

---

### **14. Output of Boyer-Moore (Moore voting)?**

```python
arr = [2,2,1,1,1,2,2]
count = 0
candidate = None
for num in arr:
    if count == 0:
        candidate = num
    count += 1 if num == candidate else -1
print(candidate)
```

A. 1
B. 2
C. None
D. Error

---

### **15. What does this code compute? (DP)**

```python
dp = [[0]*(n+1) for _ in range(n+1)]
for i in range(1,n+1):
    for j in range(1,n+1):
        if s1[i-1] == s2[j-1]:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = max(dp[i-1][j], dp[j][i-1])
```

A. LCS length
B. Edit distance
C. LC substring
D. LIS

---

| **Q.No** | **Answer** |
| -------- | ---------- |
| 1        | A          |
| 2        | C          |
| 3        | D          |
| 4        | B          |
| 5        | B          |
| 6        | B          |
| 7        | D          |
| 8        | B          |
| 9        | C          |
| 10       | C          |
| 11       | B          |
| 12       | A          |
| 13       | C          |
| 14       | B          |
| 15       | A          |

---
---